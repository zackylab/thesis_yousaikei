\begin{abstract}
　医療や災害検出などの画像処理を行う場合，処理性能と耐障害性が求められる．本研究では，処理性能と耐障害性の両立するOSSであるBroadwayと，画像処理OSSであるEvisionを利用した画像処理パイプラインの構築を検討した．Supervisorがプロセスを監視して再起動することで，このような耐障害性を実現する．しかし，Evisionに含まれるネイティブコードの実行が異常終了した場合，たとえSupervisorの監視下でも，処理系全体が終了してしまい，耐障害性が損なわれるという技術的課題があることを我々は発見した．そこで本研究では，Broadwayと，Supervisor監督下のLinuxプロセスを生成してネイティブコードを実行し，分散コンピューティング機構であるNodeを用いて通信を行うことでネイティブコード実行の耐障害性を実現するOSSであるSpawnCoElixirを組みわせることを提案する．提案手法が設計意図通りネイティブコード障害時の耐障害性を備えていることを実証するために，ネイティブコードにFault-Injectionを埋め込むことで異常終了をシミュレートした．また障害から回復するまでに必要な処理時間も計測した．Fault-Injectionを用いた異常終了シミュレーションの評価結果では，設計通りに障害復旧できることを確認した．また，障害復旧に必要な処理時間の平均は284.79nsと極めて短かった．将来課題としては，ネイティブコードで途中までデータ処理を実行できた場合に，ネイティブコード中での障害発生時にデータ消失する問題を解決することが挙げられる．
\begin{center}
  \textbf{Abstract}
\end{center}
 　Processing performance and fault tolerance are required when performing image processing for medical or disaster detection purposes. In this research, we considered building an image-processing pipeline using Broadway, an OSS that achieves both processing performance and fault tolerance, and Evision, an image-processing OSS. A supervisor monitors and restarts the observed process to achieve such fault tolerance. However, we found a technical issue: to lose fault tolerance by terminating the entire processing system even though Evision is under the Supervisor if the execution of the native code included in Evision terminates abnormally. Therefore, this research proposes a combination of Broadway and SpawnCoElixir, an OSS, to achieve fault tolerance of native code execution by spawning a Linux process under the Supervisor to execute the native code and communicating using Node, a distributed computing mechanism. In order to demonstrate that the proposed method has fault tolerance against native code faults as intended, we simulated abnormal termination by embedding a fault injection in the native code. We also measured the processing time required to recover from the fault. The evaluation results of an abnormal termination simulation using the fault injection confirmed that the native code could recover from faults as designed. The average processing time required for failure recovery was extremely short at 284.79ns. Our future works include solving the problem of data loss in the event of a fault in native code, if data processing can be executed partway through the native code.
\end{abstract}






